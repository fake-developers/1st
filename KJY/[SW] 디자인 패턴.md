# [SW] 디자인 패턴

✍️ *Assembled by JiYoung-Kwon (2021-05-20)*

## 1. 디자인 패턴이란?

* 소프트웨어를 설계할 때 **공통으로 자주 발생하는** 문제들이 또 발생했을 때 **재사용** 할 수있는 설계 방법을 정리한 패턴
* **“바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)”**
  * 이미 만들어져서 잘 되는 것을 처음부터 다시 만들 필요가 없다는 의미
* **패턴이란**
  * 각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때도 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있음
    * 이러한 유사점을 패턴이라 함
  * 패턴은 공통의 언어를 만들어주며 팀원 사이의 의사 소통을 원활하게 해주는 아주 중요한 역할을 함
* 사용 이유
  * 디자인 패턴을 참고하여 개발할 경우, 개발의 효율성과 유지보수성, 운용성이 높아지며 프로그램의 최적화에 도움이 됨

<br/>

## 2. 디자인 패턴의 구조

- 콘텍스트(context)
  - 문제가 발생하는 여러 상황을 기술함
  - 즉, 패턴이 적용될 수 있는 상황을 나타냄
  - 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 함
- 문제(problem)
  - 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술함
  - 이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 함
- 해결(solution)
  - 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술함
  - 해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.

<br/>

## 3. 디자인 패턴의 종류

#### 3-1. GoF 디자인 패턴

- GoF(Gang of Four)라 불리는 사람들
  - 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides)
  - 소프트웨어 개발 영역에서 디자인 패턴을 구체화하고 체계화한 사람들
- **23가지의 디자인 패턴을 정리하고** 각각의 디자인 패턴을 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류함

<br/>

#### 3-2. GoF 디자인 패턴의 분류

- <img src="https://gmlwjd9405.github.io/images/design-pattern/types-of-designpattern.png" alt="img" style="zoom: 33%;" />

1. **생성(Creational) 패턴**
   * 객체 생성에 관련된 패턴
   * 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공함

2. **구조(Structural) 패턴**
   * 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
   * 예를 들어, 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴

3. **행위(Behavioral) 패턴**
   * 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
   * 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둠

<br/>

#### 3-3. GoF 디자인 패턴의 종류

1. **생성(Creational) 패턴**

   * **Builder**
     * 복잡한 인스턴스를 조립하여 만드는 구조
     * 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
     * 생성과 표기를 분리해서 복잡한 객체를 생성
   * **Prototype**
     * 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴
     * 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용 되는 패턴
     * 기존 객체를 복제함으로써 객체를 생성
   * **추상 팩토리(Abstract Factory)**
     * 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
   * **팩토리 메서드(Factory Method)**
     * 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴
   * **싱글턴(Singleton)**
     * 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴

2. **구조(Structural) 패턴**

   * **Bridge**
     * 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴
     * 구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 활용
   * **컴퍼지트(Composite)**
     * 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
   * **데커레이터(Decorator)**

     * 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴
   * **Facade**
     - 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자의 시스템 간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴
     - 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴
     - 통합된 인터페이스 제공
   * **Flyweight**
     * 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스 화하여 공유함으로써 메모리를 절약하고, '클래스의 경량화'를 목적으로 하는 디자인 패턴
     * 여러 개의 '가상 인스턴스'를 제공하여 메모리 절감
   * **Proxy**
     - '실체 객체에 대한 대리 객체'로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만듬
     - 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여, 메모리 용량을 아낄 수 있음
     - 실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴
     - 특정 객체로의 접근을 제어하기 위한 용도로 사용
   * **Adapter**
     - 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
     - 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로 사용되는 디자인 패턴
     - 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움

3. **행위(Behavioral) 패턴**

  * **Mediator**

    * 객체지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법
    * 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해주는 디자인 패턴

    - 상호작용의 유연한 변경을 지원

  * **Interpreter**

    - 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴

    - 문법 자체를 캡슐화하여 사용

  * **Iterator**

    - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴

    - 내부구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴

  * **Visitor**

    - 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴
    - 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴

    - 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위

  * **Memento**

    - 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴으로 Undo 기능을 개발할 때 사용하는 디자인 패턴

    * 객체를 이전 상태로 복구시켜야 하는 경우, '작업취소(Undo)' 요청 기능

  * **Chain of Responsibility**

    - 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴

    - 한 요청을 2개 이상의 객체에서 처리

  * **옵서버(Observer)**

    * 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴

  * **스테이트(State)**

    * 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴

  * **스트래티지(Strategy)**

    * 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴

  * **템플릿 메서드(Template Method)**

    * 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴

  * **커맨드(Command)**

    * 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴

<br/>

## 📃 Reference

* [[Design Pattern] 디자인 패턴 종류](https://gmlwjd9405.github.io/2018/07/06/design-pattern.html)
* [디자인 패턴 개념과 종류](https://velog.io/@poiuyy0420/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A2%85%EB%A5%98)
* [[Design Pattern] 디자인 패턴 정의와 종류에 대하여](https://coding-factory.tistory.com/708)
* [[프로그래밍] Design Pattern Outline, 디자인 패턴이란?](https://something-is-code.tistory.com/9)