# [DATA STRUCTURE] 삽입정렬(Insertion Sort)

:writing_hand: *Assembled by JiYoung-Kwon (2021-03-22)* 



## 1. 삽입 정렬이란?

- 손 안의 카드를 정렬하는 방법과 유사함
  - 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리에 삽입함
  - 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬됨
- 자료 배열의 모든 요소를 **앞에서부터 차례로 이미 정렬된 배열 부분과 비교**하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
- 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣음
- 키 값을 두 번째 자료부터 시작하여, 그 앞의 자료들과 비교하여 알맞은 위치로 삽입하는 형태

<br/>

## 2. 삽입 정렬 과정

1. 두 번째 자료부터 시작하여, 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정함
2. 지정한 위치의 원래 자료를 뒤로 옮기고, 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘
3. 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후, 자료가 삽입될 위치를 찾음
4. 자료가 삽입될 위치를 찾았다면, 그 위치에 자료를 삽입하기 위해 자료를 뒤로 한 칸씩 이동시킴
5. 처음 Key 값은 두 번째 자료부터 시작함

<br/>

#### 2-1. 예시

![img](https://github.com/fake-developers/1st/raw/JYJ-08/JYJ/resources/InsertionSort.png)

***

* 배열에 [8, 5, 6, 2, 4] 가 저장되어 있다고 가정하고 오름차순으로 정렬하는 경우

* **1회전** - 두 번째 자료인 5를 Key값으로 하여, 그 이전의 자료들과 비교함
  * Key 값 5와, 첫 번째 자료인 8을 비교
  * 8 > 5 이므로, 8을 5자리에 넣고 Key값 5를 8의 자리인 첫 번째 자리에 기억시킴

* **2회전** - 세 번째 자료인 6을 Key 값으로 하여, 그 이전의 자료들과 비교함
   - Key 값 6과 두 번째 자료 8을 비교
     - 8 > 6 이므로, 8을 6이 있던 세 번째 자리에 기억시킴 (뒤로 이동시킴)
   - Key 값 6과 첫 번째 자료인 5를 비교
     - 5 < 6 이므로, 6을 두 번째 자리에 기억시킴
* **3회전** - 네 번째 자료인 2를 Key 값으로 하여, 그 이전의 자료들과 비교함
   - 2와 8을 비교
     - 8 > 2 이므로, 8을 네 번째 자리에 기억시킴 (뒤로 이동시킴)
   - 2와 6을 비교
     - 6 > 2 이므로, 6을 세 번째 자리에 기억시킴 (뒤로 이동시킴)
   - 2와 5를 비교
     - 5 > 2 이므로, 5를 두 번째 자리에 넣고 그 자리에 Key 값 2를 기억시킴
* **4회전** - 다섯 번째 자료인 4를 Key 값으로 하여, 그 이전의 자료들과 비교함
   - 4와 8을 비교
     - 8 > 4 이므로, 8을 다섯 번째 자리에 기억시킴
   - 4와 6을 비교
     - 6 > 4 이므로, 6을 네 번째 자리에 기억시킴
   - 4와 5를 비교
     - 5 > 4 이므로, 5를 세 번째 자리에 기억시킴
   - 4와 2를 비교
     - 4 > 2이므로, 4를 두 번째 자리에 기억시킴

***

* Gif로 보는 선택정렬

![Insertion](https://user-images.githubusercontent.com/61674527/111325893-77aa9980-86af-11eb-9917-aa5e22666a3d.gif)

<br/>

## 3. 삽입 정렬의 특징

* **장점**

  - 안정한 정렬 방법
  - 레코드의 수가 적을 경우, 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리함
  - 대부분의 레코드가 이미 정렬되어 있는 경우 매우 효율적일 수 있음
  
* **단점**

  - 비교적 많은 레코드들의 이동을 포함함
  - 레코드 수가 많고 레코드의 크기가 클 경우 적합하지 않음

<br/>

## 4. 삽입 정렬 구현

* 오름차순 조건 예시

* ```java
  public class InsertionSort {
      public static void main(String[] args) {
          int[] array = {8, 5, 6, 2, 4};
          int key;
          int i;
          int j;
  
          for (i = 1; i < array.length; i++) { // 인덱스 0은 정렬된 것으로 보고 1부터 시작함
              key = array[i]; // 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사
  
              // 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사함
              // j 값은 음수가 아니어야 함
              // key 값보다 정렬된 배열에 있는 값이 크면, j번째를 j+1번째로 이동시킴
              for (j = i - 1; j >= 0 && array[j] > key; j--) {
                  array[j + 1] = array[j]; // 레코드의 오른쪽으로 이동
              }
  
              array[j + 1] = key;
          }
  
          for (i = 0; i < array.length; i++) { // 정렬 결과 출력
              System.out.println(array[i]);
          }
      }
  }
  
  // 2, 4, 5, 6, 8
  ```


<br/>

## 5. 삽입 정렬의 복잡도

#### 5-1. 시간 복잡도

- 최선의 경우
  - 비교 횟수
    - 이동 없이 1번의 비교만 이루어진다.
    - 외부 루프 : (n-1)번
  - 시간 복잡도 : O(n)

<br/>

- 최악의 경우
  - 자료가 역순으로 입력되어 있는 경우
  - 비교 횟수
    - 외부 루프 안의 각 반복마다 i번의 비교 수행
    - 외부 루프 : (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2 = O(n^2)
  - 교환 횟수
    - 외부 루프의 각 단계마다 (i+2)번의 이동 발생
    - n(n-1)/2 + 2(n-1) = n(^2+3n-4)/2 = O(n^2)
  - 시간 복잡도 : O(n^2)

<br/>

#### :pushpin: 추가 ) 정렬의 시간 복잡도

* [선택정렬 게시물 마지막 부분 참고](./%5BDATA%20STRUCTURE%5D%20선택정렬(Selection%20Sort).md)

<br/>

## :page_with_curl: Reference

- https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html
- https://prosto.tistory.com/163
- [삽입정렬(1)](https://marobiana.tistory.com/85)
- [삽입정렬(2)](https://hahahoho5915.tistory.com/8)
- [삽입정렬(3)](https://dpdpwl.tistory.com/18)
- [삽입정렬(4)](https://www.daleseo.com/sort-insertion/)
- [삽입정렬(5)](https://mingcoder.me/2019/12/29/Programming/Algorithm/sort-implement/)
- [삽입정렬(위키피디아)](https://ko.wikipedia.org/wiki/삽입_정렬)