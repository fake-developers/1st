## 디자인패턴(Design Pattern)

<br/>

### <u>정의</u>

* 소프트웨어 개발 방법으로 사용된다.
* 과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 그 방법에 이름을 붙여서 이후에 재사용하기 좋은 형태로 특정 규약을 만들어서 정리한 것
* 소프트웨어 설계에 있어 공통적인 문제들에 대한 표준적인 해법과 작명법을 제안한다.
* 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수있는 훌륭한 해결책
* 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, 특정한 상황에서 구조적인 문제를 해결하는 방식
* 효율적인 코드를 만들기 위한 방법론
* "Don't reinvent the wheel(바퀴를 다시 발명하지 마라)"
  * 이미 만들어져서 잘 되는 것을 처음부터 다시 만들 필요가 없다는 의미

<br/>

#### 패턴이란

* 각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때도 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있다. 이러한 유사점을 패턴이라 한다.
* 패턴은 공통의 언어를 만들어주며 팀원 사이의 의사 소통을 원활하게 해주는 아주 중요한 역할을 한다.

<br/>

### <u>구조</u>

- **콘텍스트(context)**
  * 문제가 발생하는 여어 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다.
  * 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.
- **문제(problem)**
  * 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다.
  * 이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다.
- **해결(solution)**
  * 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다.
  * 해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.

<br/>

### <u>종류</u>

#### GoF 디자인 패턴

* GoF(Gang of Fou)라 불리는 사람들
  * 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides)
    소프트웨어 개발 영역에서 디자인 패턴을 구체화하고 체계화한 사람들
    23가지의 디자인 패턴을 정리하고 각각의 디자인 패턴을 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류했다.

![디자인패턴](https://user-images.githubusercontent.com/61674527/118918011-07e5b300-b96d-11eb-8ffe-7f69e7733efd.JPG)

#### 생성(Creational) 패턴

> **객체 생성에 관련된 패턴. 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.**

* **싱글톤 패턴(Singleton)** : 클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴으로, 디자인 패턴의 가장 많이 알려진 패턴.
  * 인스턴스가 하나뿐이기 때문에 불필요한 메모리 낭비를 최소화 할 수 있다.
* **추상팩토리 패턴(Abstract Factory)** : 구체적인 클래스를 지정하지 않고 관련성이 있거나, 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴.
  * 연관된 서브 클래스를 묶어 한 번에 교체 가능.
* **빌더 패턴Builder)** : 복학 객체의 생성과정과 표현과정을 분리시켜 동일한 생성과정에서 다양한 표현을 생성할 수 있는 패턴.
  * 동일한 객체 생성에서도 다른 결과 나올 수 있다.
* **팩토리 메서드 패턴(Factory Method)** : 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록 하는 패턴.  
  * 캡슐화하는 패턴

#### 구조(Structural) 패턴

> **클래스나 객체를 조합해 더 큰 구조를 만드는 패턴. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴이다.**

* **적응자 패턴(Adapter or Wrapper)** : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴이다.
  * 기존의 클래스를 이용하고 싶은데 인터페이스가 일치하지 않을 때 사용
  * 호환성을 맞춰주는 변압기
* **데코레이터 패턴(Decorator)** : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴 
  * 기능확장이 필요할 때 서브클래스 대신 쓸 수 있는 대안이 될 수 있다.
  * 온갖 것으로 장식된 눈사람
* **퍼사드 패턴(Facade)** :서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공한다. 
  * 상위에 인터페이스를 구성하여 서브 클래스들의 기능을 수행할 수 있다.
  * 서브시스템을 좀 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의한다.
  * 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체 필요
  * 리모컨만으로 복잡한 명령을 수행하는 것
* **프록시 패턴(Proxy)** :어떤 다른 객체로 접근하는 것을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공하는 패턴이다.
* **컴퍼지트 패턴(Composite)** : 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
  * 복합 객체 안에 복합 객체가 포함되는 구조 구현 가능
  * 폴더와 파일을 합성한 것

#### 행위(Behavioral) 패턴

> **객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴. 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.**

* **옵저버 패턴(Observer)** : 객체들 사이에 1 : N 의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존관계에 있는 모든 객체들이 통지받고 자동으로 갱신될 수 있게 만드는 패턴이다.
  * 시스템간에 이벤트를 생성하고 수신할 때 사용
  * 변화를 지켜보고 알려주는 것
* **상태 패턴(State)** : 객체의 내부 상태가 변경될 때 행동을 변경하도록 허락합니다. 객체는 자신의 클래스가 변경되는 것처럼 보이게 됩니다.
  * 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용
  * 객체 상태를 캡슐화하고 이를 참조
  * 상태에 따라 다른 방법을 사용
* **스트레이트지 패턴(Strategy)** : 동일 계열의 알고리즘들을 정의하고, 각각 캡슐화하며 이들을 상호교환 가능하도록 만드는 것이다. 
  * 알고리즘을 사용하는 사용자로부터 독립적으로 알고리즘이 변경될 수 있도록 하는 패턴
* **템플릿 패턴Template)** : 객체의 연산에서 알고리즘의 뼈대만 정의하고, 나머지는 서브클래스에서 이루어지게 하는 패턴이다.  
  * 알고리즘의 구조는 변경하지 않고 알고리즘의 각 단계를 서브클래스에서 재정의하게 된다.
  * 여러 전략을 정하고 필요할 때 선택하여 쓴다.
* **비지터 패턴(Visitor)** : 객체구조를 이루는 원소에 대해 수행할 연산을 표현한다. 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 새로운 연산을 재정의 할 수 있습니다.
  * 각 클래스들의 데이터 구조에서 처리 기능을 별도의 클래스로 구성
  * 분리된 기능은 각 클래스를 방문하여 수행
  * 책을 만들기 위해 저자, 편집자를 번갈아가며 방문하는 것
* **역할 사슬 패턴(Chain of Responsibility)** : 요청을 처리하는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴이다.
  * 요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있을 때까지 요청을 전달한다.
  * 한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴
  * 요청이 해결될 때까지 고리를 따라 책임이 넘어감
  * 연속해서 나눠받는 물레방아
* **커맨드 패턴(Command)** : 요청을 객체로 캡슐화하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴이다.
  * 요청을 캡슐화하여 재이용하거나 취소할 수 있도록 저장하거나 로그로 남김
  * 추상클래스와 구체클래스로 나눈다.
  * 명령어를 하나로 합쳐둔 것
* **인터프리터 패턴(Interpreter)** : 주어진 언어에 대해서 문법을 위한 표현수단을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴이다.
  * SQL이나 통신 프로토콜에 사용
* **이터레이터 패턴(Iterator)** : 내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴이다.
  * 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 함
  * 같은 명령의 반복
* **미디에이터 패턴(Mediator) :** 한 집합에 속해있는 객체들의 상호 작용을 캡슐화하는 객체를 정의하는 패턴이다. 
  * 중재자는 객체들이 직접 서로 참조하지 않도록함으로써 객체들간의 느슨한 연결을 촉진시키며 객체들의 상호작용을 독립적으로 다양화 시킬 수 있도록 해준다.
  * 매매를 중개해주는 중개사이트

<br/>

***

*자세한 정보를 보고싶으시면 [여기](https://gmlwjd9405.github.io/2018/07/06/design-pattern.html) 맨 아래쪽 `관련된 Post`를 참고하세요*

<br/>

<br/>

<br/>

### REFERENCE

* [[Design Pattern]디자인 패턴 종류](https://gmlwjd9405.github.io/2018/07/06/design-pattern.html)
* [소프트웨어 디자인 패턴](https://itwiki.kr/w/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4#.EC.B6.94.EC.83.81_.ED.8C.A9.ED.86.A0.EB.A6.AC)
* [[Design Pattern]디자인 패턴 정의와 종류에 대하여](https://coding-factory.tistory.com/708)

