## 데드락(Dead lock)



### <u>데드락(Dead lock)이란?</u>

교착상태라고 하며, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 말한다.

<br/>

### <u>데드락의 발생조건</u>

#### 상호 배제(Mutual exclusion)

* 한번에 프로세스 하나만 해당 자원을 사용할 수 있다.
* 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야한다.

#### 점유 대기(Hold and sait)

* 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

#### 비선점 (No preemption)

* 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야한다.

#### 순환 대기 (Circular wait)

* 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

<br/>

### <u>데드락의 해결법</u>

#### 교착 상태 예방 및 회피

* 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법

#### 교착 상태 탐지 및 회복

* 교착 상태가 되도록 허용한 다음에 회복시키는 방법

#### 교착 상태 무시

* 대부분의 시스템은 교착 상태가 잘 발생하지 않으며, 교착 상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

<br/>

### <u>데드락 예방(Prevention)</u>

발생조건 4가지 중 하나라도 발생하지 않게 하는 것.

* 각 조건을 방지(부정)하여 데드락 발생 가능성을 차단.
* 시스템의 처리량이나 효율성을 떨어트리는 단점이 발생할 수 있다.

#### 상호 배제(Mutual exclusion) 부정

* 한번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다.
  * 추후 동기화 관련 문제가 발생할 수 있다.

#### 점유 대기(Hold and sait) 부정

* 프로세스가 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.

#### 비선점 (No preemption) 부정

* 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위긔 프로세스가 해당 자원을 선점할 수 있도록 한다.

#### 순환 대기 (Circular wait) 부정

* 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.

<br/>

### <u>데드락 회피(Avoidance)</u>

예방법보다는 조금 덜 제한적인 방법으로 예방법의 단점을 일부 해결할 수 있다.

`Safe sequence`, `Safe state`

* 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해줄 수 있다면 **안정 상태(safe state)**에 있다고 말한다.
* 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 **안전 순서(safe sequence)**라고 부른다.
* **불안정 상태**는 데드락 발생 가능성이 있는 상황이며, 교착상태는 불안정 상태일 때 발생할 수 있다. (교착 상태가 불안정 상태의 부분집합)
* **회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 safe state에 있을 수 있도록 할당을 허용하자**는 것이 기본 특징이다. (은행원 알고리즘)

#### 은행원 알고리즘(Banker's Algorithm)

E,J,Dijkstra가 제안한 방법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법.

* 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태(safe state)로 남아있게 되는지를 사전에 검사하고 교착 상태를 회피하는 기법
* 안정상태 (safe state)에 있으면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해지 할 때까지 대기한다.

<img src="https://user-images.githubusercontent.com/61674527/104850188-f219a000-5930-11eb-8dae-509a75b37b6e.jpg" style="zoom:45%;" />

* 미리 최대 자원 요구량을 알아야하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약 조건이 많고, 그에 따른 자원 이용도 하락 등 단점이 존재한다.

<br/>

### <u>데드락 탐지(Detection) 및 회복(Recovery)</u>

시스템이 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 회복하기 위해 탐지하고, 회복하는 알고리즘을 사용한다.

#### 탐지 기법

* Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색한다.

  * 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악

* 자원 할당 그래프를 통해 탐지하는 방법도 있다.

  <img src="https://user-images.githubusercontent.com/61674527/104850200-0493d980-5931-11eb-843d-31fd6da2a6b6.jpg" style="zoom: 80%;" />

  * 프로세스 Pi로부터 자원 Rj로의 방향 간선은 Pi → Rj로 표현하며, 이것은 프로세스 Pi가 자의 것을 요청하는 것으로 현재 이 자원을 기다리는 상태이다.
  * 자원 Rj로부터 프로세스 Pi로의 방향 간선은 Rj → Pi로 표현하며, 이것은 자원의 것이 프로세스 Pi에 할당된 것을 의미한다.

* 자원을 요청할 때마다 탐지 알고리즘을 실행하면 오버헤드가 발생한다.

#### 회복기법

* 데드락을 탐지 기법을 통해 발견했다면, 데드락으로부터 회복하기 위한 방법

  * **단순히 프로세스를 1개 이상 중단 시키기**

    * **교착상태에 빠진 모든 프로세스를 중단 시키는 방법**

      계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기 될 수 있는 부작용이 발생할 수 있음

    * **프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법**

      매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음

  * 자원 선점하기

    * 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법

<br/>

<br/>

<br/>

### REFERENCE

* [데드락](https://includestdio.tistory.com/12)
* [데드락2](https://chanhuiseok.github.io/posts/cs-2/)

