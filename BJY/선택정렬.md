## 선택정렬(Selection Sort)

<br/>

### <u>**정의**</u>

* 제자리 정렬 알고리즘의 하나
  - 제자리 정렬 : 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
* 해당 순서에 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

<br/>

### <u>특징</u>

* 선택 정렬은 정렬된 값을 배열의 맨 앞부터 하나씩 채워나가게 된다. 따라서, 뒤에 있는 index로 갈수록 비교 범위가 하나씩 점점 줄어드는 특성을 가지고 있다. (index 0에서는 0부터 n-1까지 비교해야 되지만, index n-1에서는 남은 숫자가 하나 밖어서 비교가 필요 없음)
* 불안정 정렬이다. 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.
* 입력 배열이 이미 정렬되어 있건 말건 관계없이 동일한 연산량을 가지고 있기 때문에 최적화 여자가 적어서 다른 `O(N^2)` 대비해도 성능이 떨어지는 편이다.
* 이러한 성능 상의 한계 때문에 실전에서는 거의 보기 힘들지만, 가장 구현이 쉬운 정렬 알고리즘이라서, 알고리즘 수업 시간에는 한 번씩 꼭 접하게 되는 유명한 정렬 알고리즘이다.

<br/>

### <u>복잡도 분석</u>

* 선택 정렬은 별도의 추가 공간을 사용하지 않고 주어진 배열이 차지하고 있는 공간 내에서 값들의 위치만 바꾸기 때문에 `O(1)`의 공간 복잡도를 가진다.
* 시간 복잡도는 우선 루프문을 통해 모든 인덱스에 접근해야 하기 때문에 기본적으로 `O(N)`을 시간을 소모하며, 하나의 루프에서는 현재 인덱스의 값과 다른 인덱스의 값들과 비교하여 최소값을 찾은 후 현재 인덱스에 있는 값과 상호 자리 교대를(swap)해야 해야하기 때문에 `O(N)`을 시간이 필요하게 된다. 따라서 선택 정렬은 총 `O(N^2)`의 시간 복잡도를 가지는 정렬 알고리즘이다.

<br/>

### <u>개념</u>

선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.

![selection](https://user-images.githubusercontent.com/61674527/112001255-247a9000-8b62-11eb-9ad9-18aab00137e6.gif)

<br/>

예를 들어, 1~5까지 5개의 숫자가 들어있는 배열이 있다고 가정한다. **i**는 현재 index, **m**은 가장 작은 값이 있는 index를 가르킨다.

```java
 i
[3, 4, 5, 1, 2]
          m
```

> 우선 index 0에 놓을 값을 찾아야 한다. 모든 숫자 중 가장 작은 숫자인 `1`을 index 3에서 찾는다. `1`을 index 0에 위치시키기 위해서 위해서 원래 index 0에 있던 `3`과 `1`의 자리를 바꾼다.

> 
>

<br/>

### <u>구현</u>

<br/>

#### 최적화



<br/>

<br/>

<br/>

### REFERENCE

* 
