## 선택정렬(Selection Sort)

<br/>

### <u>**정의**</u>

* 제자리 정렬 알고리즘의 하나
  - 제자리 정렬 : 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
* 해당 순서에 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

<br/>

### <u>특징</u>

* 선택 정렬은 정렬된 값을 배열의 맨 앞부터 하나씩 채워나가게 된다. 따라서, 뒤에 있는 index로 갈수록 비교 범위가 하나씩 점점 줄어드는 특성을 가지고 있다. (index 0에서는 0부터 n-1까지 비교해야 되지만, index n-1에서는 남은 숫자가 하나 밖어서 비교가 필요 없음)
* 불안정 정렬이다. 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.
* 입력 배열이 이미 정렬되어 있건 말건 관계없이 동일한 연산량을 가지고 있기 때문에 최적화 여자가 적어서 다른 `O(N^2)` 대비해도 성능이 떨어지는 편이다.
* 이러한 성능 상의 한계 때문에 실전에서는 거의 보기 힘들지만, 가장 구현이 쉬운 정렬 알고리즘이라서, 알고리즘 수업 시간에는 한 번씩 꼭 접하게 되는 유명한 정렬 알고리즘이다.

<br/>

### <u>복잡도 분석</u>

* 선택 정렬은 별도의 추가 공간을 사용하지 않고 주어진 배열이 차지하고 있는 공간 내에서 값들의 위치만 바꾸기 때문에 `O(1)`의 공간 복잡도를 가진다.
* 시간 복잡도는 우선 루프문을 통해 모든 인덱스에 접근해야 하기 때문에 기본적으로 `O(N)`을 시간을 소모하며, 하나의 루프에서는 현재 인덱스의 값과 다른 인덱스의 값들과 비교하여 최소값을 찾은 후 현재 인덱스에 있는 값과 상호 자리 교대를(swap)해야 해야하기 때문에 `O(N)`을 시간이 필요하게 된다. 따라서 선택 정렬은 총 `O(N^2)`의 시간 복잡도를 가지는 정렬 알고리즘이다.

<br/>

### <u>개념</u>

선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.

![selection](https://user-images.githubusercontent.com/61674527/112001255-247a9000-8b62-11eb-9ad9-18aab00137e6.gif)

<br/>

예를 들어, 1~5까지 5개의 숫자가 들어있는 배열이 있다고 가정한다. **i**는 현재 index, **m**은 가장 작은 값이 있는 index를 가르킨다.

```java
 i
[3, 4, 5, 1, 2]
          m
```

> 우선 index 0에 놓을 값을 찾아야 한다. 모든 숫자 중 가장 작은 숫자인 `1`을 index 3에서 찾는다. `1`을 index 0에 위치시키기 위해서 위해서 원래 index 0에 있던 `3`과 `1`의 자리를 바꾼다.
>
> ```java
>    i
> [1, 4, 5, 3, 2]
>              m
> ```

> 다음으로 index 1에 놓을 값을 찾아야 한다. `1`을 제외하고 남은 숫자 중에서 가장 작은 숫자인 `2`를 index 4에서 찾았다. `2`를 index 1에 위치시키기 위해서 원래 index 1에 있던 `4`와 `2`의 자리를 바꾼다.
>
> ```java
>       i
> [1, 2, 5, 3, 4]
>           m
> ```

>다음으로 index 2에 놓을 값을 찾아야 한다. `1`, `2`를 제외하고 남은 숫자 중에서 가장 작은 숫자인 `3`를 index 3에서 찾았다. `3`를 index 2에 위치시키기 위해서 원래 index 2에 있던 `5`와 `3`의 자리를 바꾼다.
>
>```java
>          i
>[1, 2, 3, 5, 4]
>             m
>```

> 다음으로 index 3에 놓을 값을 찾아야 한다. `1`, `2`, `3`를 제외하고 남은 숫자 중에서 가장 작은 숫자인 `4`를 index 4에서 찾았다. `4`를 index 3에 위치시키기 위해서 원래 index 3에 있던 `5`와 `4`의 자리를 바꾼다.
>
> ```java
>              i
> [1, 2, 3, 4, 5]
>              m
> ```

> 마지막으로 index 4에 놓을 값을 찾아야 g한다. `1`, `2`, `3`, `4`를 제외한 남은 숫자는 `5` 밖에 없으며 따라서 지동으로 `5`가 가장 작은 숫자가 된다.

<br/>

### <u>구현</u>

두 개의 반복문이 필요하다. 내부 반복문에서는 현재 index부터 마지막 index까지 최소값의 index를 찾아내고, 외부 반복문에서는 이 최소값의 index와 현재 index에 있는 값을 상호 교대(swap)한다. 외부 반복문에서는 index `i`를 `0`에서 `n-2`(또는 `n-1`. 마지막 index에서는 남는 값이 하나 밖에 없기 때문에 대세에 지장 없음)까지 진행시키며, 내부 반복문에서 이미 정렬된 값들에서는 관심이 없기 때문에 index `j`를 `i`에서 `n-1`까지 진행시킨다. 각 index에 대해서 최소값을 찾기 위해 대소 비교는 여러번 일어나나 상호 교대(swap)은 딱 한번만 알어난다.

<br/>

```java
public class Selection {
    public static void sort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIdx])
                    minIdx = j;
            }
            swap(arr, i, minIdx);
        }
    }

    private static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
```

<br/>

<br/>

<br/>

### REFERENCE

* [선택정렬(1)](https://github.com/fake-developers/1st/blob/SJH-08/SJH/Selection%20sort.md)
* [선택정렬(2)](https://github.com/fake-developers/1st/blob/KJY-08/KJY/%5BDATA%20STRUCTURE%5D%20%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC(Selection%20Sort).md)
* [선택정렬(3)](https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html)
* [선택정렬(4)](https://velog.io/@rachell_lee/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%A0%95%EB%A0%AC-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC)
* [선택정렬(5)](https://www.daleseo.com/sort-selection/)
* [선택정렬(위키피디아)](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC)
